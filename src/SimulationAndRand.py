import random
import math
import sympy as smp
import numpy as np


def random_mixed_congruential_generator(a, c, m, x_zero, upper_bound):
    """Calculates all the numbers generated by a mixed congruential random number
    generators.
    param: a is a constant
    param: c is a constant
    param: m is the modulo
    param: x_zero is the seed
    param: is an upper bound for the cycle
    returns a list of all numbers generated"""
    numbers_generated = []
    it = 0
    current_x = x_zero
    while it <= upper_bound:
        next_x = (a * current_x + c) % m
        numbers_generated.append(next_x)
        if next_x == x_zero:
            break
        current_x = next_x
        it += 1
    return numbers_generated


def uniform_random_from_mixed_congruential_generator(a, c, m, x_zero, upper_bound):
    """Calculates all the numbers generated by a mixed congruential random number
    generators and divides them by the modulo to get a uniform distribution.
    param: a is a constant
    param: c is a constant
    param: m is the modulo
    param: x_zero is the seed
    param: is an upper bound for the cycle
    returns a list of all numbers generated"""
    numbers_generated = []
    it = 0
    current_x = x_zero
    while it <= upper_bound:
        next_x = (a * current_x + c) % m
        numbers_generated.append((next_x + (1 / 2)) / m)
        if next_x == x_zero:
            break
        current_x = next_x
        it += 1
    return numbers_generated


"""
    Example:
    a = 10
    b = 20
    m = 1.0/50.0 * (20.0 - 10.0)
    function = "1.0/50.0 * (x - 10.0)"
    print(generate_acceptance_rejection(m, a, b, function, 100))
"""


def generate_acceptance_rejection(m, a, b, function, upper_limit):
    """Calculates a random observation from a function that has a range [a,b]
    using the acceptance
    rejection method
    param: m is the highest image of the funcion
    param: a is a constant
    param: b is a constant
    param: function is the desired function written as a string
    param: upper_limit the amount of times the simulation is run
    returns the random image generated"""
    for i in range(0, upper_limit):
        first_random = random.uniform(0, 1)
        second_random = random.uniform(0, 1)
        x = a + (b - a) * first_random
        evaluation_image = eval(function)
        if second_random <= evaluation_image / m:
            print("The evaluation image was found correctly")
            break
    print("First random " + str(first_random))
    print("Second random " + str(second_random))
    return evaluation_image


def generate_random_variables_with_inverse_transform(
    a, b, function, n_variables_to_generate
):
    """Calculates random observations from a function within a given range [a,b]

    Parameters:
    a (float): lower bound of the range
    b (float): upper bound of the range
    function (sympy expression): function expression
    n_variables_to_generate (int): number of random variables to generate

    Returns:
    None
    """
    x = smp.symbols("x", real=True)
    integrated = smp.integrate(function, x)
    n = n_variables_to_generate
    y = smp.symbols("y", real=True)
    eq = smp.Eq(integrated, y)

    try:
        inverse = smp.solve(eq, x)
    except smp.PolynomialError:
        print("Error: The inverse of the function cannot be calculated.")
        return

    sequence_x = []
    sequence_y = []

    for _ in range(n):
        r_value = random.uniform(a, b)
        x_value = inverse[0].subs(y, r_value).evalf()
        sequence_y.append(r_value)
        sequence_x.append(x_value)

    print("\nThe random variables generated in interval [a, b] are as follow:")
    for i in range(n):
        print(f"X generated: {sequence_x[i]} - with r: {sequence_y[i]}")


def generate_acceptance_rejection_with_symp(a, b, function, upper_limit):
    """
    Generates a random observation from a function within the range [a,b]
    using the acceptance-rejection method.

    Args:
        a (float): Lower bound of the range.
        b (float): Upper bound of the range.
        function (str): The desired function written as a string.
        upper_limit (int): The maximum number of iterations to run the simulation.

    Returns:
        float: The random number generated or None if no suitable number was found within upper_limit iterations.
    """
    x = smp.symbols("x", real=True)
    f = smp.sympify(function)

    # Compute maximum of function
    x_values = np.linspace(a, b, 10000)
    m = max([f.subs(x, val).evalf() for val in x_values])
    print(f"\nM is = {m}")

    for i in range(upper_limit):
        first_random = random.uniform(a, b)
        second_random = random.uniform(0, 1)
        x_value = a + (b - a) * first_random
        evaluation_image = f.subs(x, x_value).evalf()

        if second_random <= evaluation_image / m:
            print("The evaluation image was found correctly")
            print("First random: ", first_random)
            print("Second random: ", second_random)
            return evaluation_image

    print("No suitable random number found within upper_limit iterations.")
    return None


# # example of inverse transformation
# # define the function
# x = smp.symbols("x", real=True)
# function = x + 5  # this is your mathematical function
# # use the function to generate random variables
# generate_random_variables_with_inverse_transform(0, 1, function, 10)
# # Define your bounds and upper limit
# a = 0
# b = 1
# upper_limit = 10000
# # examples of acceptance rejection
# # Use the function to generate a random number
# random_number = generate_acceptance_rejection_with_symp(a, b, function, upper_limit)

# print("\nGenerated random number: ", random_number)
